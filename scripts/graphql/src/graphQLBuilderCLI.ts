import { dirname, resolve } from "path";

import { codegen } from "@graphql-codegen/core";
import type { Types } from "@graphql-codegen/plugin-helpers/typings";
import * as typescriptPlugin from "@graphql-codegen/typescript";
import * as typescriptGraphqlRequestPlugin from "@graphql-codegen/typescript-graphql-request";
import * as typescriptOperationsPlugin from "@graphql-codegen/typescript-operations";
import * as typescriptResolversPlugin from "@graphql-codegen/typescript-resolvers";
import glob from "tiny-glob";

import type { TypeDef } from "./GraphQLBuilder";
import { GraphQLBuilder } from "./GraphQLBuilder";
import { GeneratedFilesReporter } from "../../utils/fileGenerator/GeneratedFilesReporter";
import {
	GENERATED_HEADER_GRAPHQL,
	GENERATED_HEADER_TS,
} from "../../utils/fileGenerator/generatorConsts";
import { isGenerated } from "../../utils/fileGenerator/isGenerated";
import { safeWriteGeneratedFile } from "../../utils/fileGenerator/safeWriteGeneratedFile";

import { mkdirp, readdir, readJSONFile, readUTF8File } from "~/lib/fs";
import { print } from "~/lib/graphql/graphql";
import type { DocumentNode } from "~/lib/graphql/graphql";
/**
 * A tool for generating GraphQL schema files from a set of input files specified under `include`. The tool has 4 output
 * types that can be used separately or in combination:
 *
 * 1) Build (`buildDir`)
 *    Scans all included files for template types and generates the corresponding type definitions. Each generated type
 *    definition is written to its own file. It is also possible to write the generated types to a location that is
 *    included in the `include` list.
 *
 * 2) Bundle (`bundle`)
 *    Recursively determines all types referenced by the entry point type and places the type definitions in a single
 *    file. Any types that are not referenced by the entry point type are discarded. In contrast to build mode, the
 *    bundle will also contain non-template types. Defaults to using the schema definition as the entry point.
 *
 * 3) TypeScript schema (`tsSchema`)
 *    Generates a TypeScript file containing the GraphQL schema and resolver types. The types are generated by bundling
 *    the schema first and then generating the TypeScript types from the bundle. The entry point option therefore also
 *    applies to this output type.
 *
 * 4) TypeScript requests (`tsRequests`)
 *    Scans the included files for GraphQL operations and generates a TypeScript file containing types and code to
 *    execute the operations. The types are generated by bundling the schema first and then generating the TypeScript
 *    types from the bundle. The entry point option therefore also applies to this output type.
 *
 * The files listed under `include` control which graphQL files are taken into account for the above outputs. Can be
 * a single path or an array of paths and/or globs. In addition, the `project` option can be used to specify a project
 * name, in which case the tool will consult the `.graphqlconfig` file and use the `includes` property from that file.
 * The includes from the `project` option will be added to the includes specified under `include`.
 */
export async function graphQLBuilderCLI(o: IOptions) {
	// Treating an empty string as undefined makes sense here, hence we can disable the rule.
	// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
	if (!o.include && !o.project) {
		throw new Error("Must specify either include or project option");
	}

	if (!o.bundle && !o.build && !o.buildDir && !o.tsSchema && !o.tsRequests) {
		throw new Error("No outputs specified");
	}

	// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
	const include: string[] = o.include ? (Array.isArray(o.include) ? o.include : [o.include]) : [];
	const exclude: string[] = [];

	if (o.project) {
		// Try to find the closest .graphqlconfig file.
		let dir = process.cwd();
		let graphqlConfig: any;
		do {
			try {
				graphqlConfig = await readJSONFile([dir, "./.graphqlconfig"]);
			} catch (e: any) {
				// We can only deal with ENOENT errors (file not found). If it's anything else, we'll just rethrow it.
				// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
				if (e.code !== "ENOENT") throw e;
				dir = resolve(dir, "..");
			}
		} while (dir !== "/" && graphqlConfig === undefined);

		// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment
		const includes: string[] = graphqlConfig?.projects?.[o.project]?.includes;
		// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment
		const excludes: string[] = graphqlConfig?.projects?.[o.project]?.excludes ?? [];

		if (!Array.isArray(includes)) {
			throw new Error("Invalid graphql config file.");
		}

		if (!Array.isArray(excludes)) {
			throw new Error("Invalid graphql config file.");
		}

		// Transform the paths to absolute paths and add them to the include list.
		include.push(...includes.map((pattern) => resolve(dir, pattern)));

		exclude.push(...excludes.map((pattern) => resolve(dir, pattern)));
	}

	// The list of absolute file paths to process, populated by glob pattern
	const files = new Set<string>();
	for (const pattern of include) {
		const result = await glob(pattern, { filesOnly: true, absolute: true });
		for (const match of result) files.add(match);
	}

	for (const pattern of exclude) {
		const result = await glob(pattern, { filesOnly: true, absolute: true });
		for (const match of result) files.delete(match);
	}

	const typeDefs: Promise<TypeDef>[] = [];
	for (const filename of files) {
		typeDefs.push(readUTF8File(filename).then((content) => ({ filename, content })));
	}

	const builder = new GraphQLBuilder(
		(await Promise.all(typeDefs))
			// Don't pass generated files to GraphQLBuilder because it will not regenerate them. The effect would be
			// that generated types would never be updated.
			.filter((typeDef) => !isGenerated(typeof typeDef === "string" ? typeDef : typeDef.content))
	);

	const report = new GeneratedFilesReporter();

	if (o.bundle) {
		await outputBundle(builder, { output: o.bundle }, report);
	}

	if (o.buildDir) {
		await outputBuild(builder, { output: o.buildDir }, report);
	}

	if (o.build) {
		await outputBuild(builder, { output: o.build, concat: true }, report);
	}

	if (o.tsSchema) {
		await outputTsSchema(builder, { output: o.tsSchema }, report);
	}

	if (o.tsRequests) {
		await outputTsRequests(builder, { output: o.tsRequests }, report);
	}

	return {
		include,
		exclude,
		files: report.entries,
	};
}

export interface IOptions {
	/**
	 * The path to write the generated file to.
	 */
	build?: string;

	/**
	 * The directory to write the generated files to.
	 */
	buildDir?: string;

	/**
	 * Path to where the generated bundle should be written.
	 */
	bundle?: string;

	/**
	 * Where to write the generated TypeScript types to.
	 */
	tsSchema?: string;

	/**
	 * Where to write the generated TypeScript file for requests to.
	 */
	tsRequests?: string;

	/**
	 * Which files to include in the build. Can be a glob pattern or an array of glob patterns.
	 */
	include?: string | string[];

	/**
	 * If specified, consults the .graphqlconfig file for which files to include.
	 */
	project?: string;
}

async function outputBundle(
	builder: GraphQLBuilder,
	o: { output: string },
	report: GeneratedFilesReporter
) {
	const fileContents: string = print(builder.bundle());

	await mkdirp(dirname(o.output));
	await safeWriteGeneratedFile(o.output, `${GENERATED_HEADER_GRAPHQL}\n\n${fileContents}`, report);

	report.written(o.output);
}

async function outputBuild(
	builder: GraphQLBuilder,
	o: { output: string; concat?: boolean },
	report: GeneratedFilesReporter
) {
	const generated = builder.generateTypeDefs();

	if (o.concat) {
		// Output to a single file
		const fileContents: string = [...generated.values()].map(print).join("\n\n");
		await mkdirp(dirname(o.output));

		await safeWriteGeneratedFile(
			o.output,
			`${GENERATED_HEADER_GRAPHQL}\n\n${fileContents}`,
			report
		);

		report.written(o.output);
		return;
	}

	await mkdirp(o.output);

	// The list of files present in the output directory. Will use this to determine which files to delete.
	// These are just the filenames, not the full paths.
	const deleteCandidates = new Set(await readdir(o.output));

	const promises = [];
	for (const [typeName, typeDef] of generated) {
		const filename = `${typeName}.graphql`;
		// The generated file should not be deleted, so remove it from the delete candidates.
		deleteCandidates.delete(filename);
		promises.push(
			safeWriteGeneratedFile(
				[o.output, filename],
				`${GENERATED_HEADER_GRAPHQL}\n\n${print(typeDef)}`,
				report
			)
		);
	}

	// Delete any files that are not in the generated list.
	for (const filename of deleteCandidates) {
		promises.push(safeWriteGeneratedFile([o.output, filename], null, report));
	}

	await Promise.all(promises);
}

async function outputTsSchema(
	builder: GraphQLBuilder,
	o: { output: string },
	report: GeneratedFilesReporter
) {
	const output = o.output;

	const document = builder.bundle();

	const options = getCodegenBaseOptions(document, {
		typescriptResolvers: typescriptResolversPlugin,
	});

	Object.assign(options.config, {
		maybeValue: "T | null | undefined",
		defaultMapper: `ResolverReturnType<{T}>`,
		contextType: "../IGraphQLContext#IGraphQLContext",
	});

	const tsTypeDefs = await codegen(options);

	const fileContents = `${GENERATED_HEADER_TS}\nimport { ResolverReturnType } from "~/lib/utils/types";\n${tsTypeDefs}`;

	// Ensure the directory where the output file should be written to exists.
	await mkdirp(dirname(output));
	await safeWriteGeneratedFile(output, fileContents, report, true);
	report.written(output);
}

async function outputTsRequests(
	builder: GraphQLBuilder,
	o: { output: string },
	report: GeneratedFilesReporter
) {
	const output = o.output;

	const typesDocument = builder.bundle();

	const operationsDocument = builder.operations();

	const options = getCodegenBaseOptions(typesDocument, {
		typescriptOperations: typescriptOperationsPlugin,
		typescriptGraphqlRequest: typescriptGraphqlRequestPlugin,
	});

	options.documents.push({ document: operationsDocument });

	const tsTypeDefs = `${GENERATED_HEADER_TS}\n${await codegen(options)}`;

	// Ensure the directory where the output file should be written to exists.
	await mkdirp(dirname(output));
	await safeWriteGeneratedFile(output, tsTypeDefs, report, true);
	report.written(output);
}

function getCodegenBaseOptions(
	document: DocumentNode,
	plugins: Types.GenerateOptions["pluginMap"]
): Types.GenerateOptions {
	return {
		documents: [],
		config: {
			typesPrefix: "I",
			// Will use `import type {}` rather than `import {}` when importing only types.
			useTypeImports: true,
			scalars: {
				DateTime: "string",
			},
		},
		// Setting a dummy filename here, because it is not used but only required to bypass a validation check in the
		// codegen library.
		filename: "out.ts",
		schema: document,
		plugins: [
			// Each plugin should be an object
			{ typescript: {} },
			...Object.keys(plugins).map((name) => ({ [name]: {} })),
		],
		pluginMap: {
			typescript: typescriptPlugin,
			...plugins,
		},
	};
}
