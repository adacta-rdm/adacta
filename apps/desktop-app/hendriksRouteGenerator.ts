import { readdirSync } from "node:fs";
import { parse } from "node:path";

import { GeneratedFilesReporter } from "~/scripts/utils/fileGenerator/GeneratedFilesReporter";
import { GENERATED_HEADER_TS } from "~/scripts/utils/fileGenerator/generatorConsts";
import { safeWriteGeneratedFile } from "~/scripts/utils/fileGenerator/safeWriteGeneratedFile";

// This is a CLI script -> console.log allowed
/* eslint-disable no-console */

async function main() {
	const path = "./src/routes";
	const routeOut = "./src/routes.ts";
	const routeConfigOut = "./src/route-config.ts";

	const report = new GeneratedFilesReporter();

	const files: IGenerateParams[] = readdirSync(path)
		.filter((file) => file.endsWith(".tsx") || file.endsWith(".ts"))
		.sort()
		.map((file) => ({
			file,
			route:
				// eslint-disable-next-line prefer-template
				"/" +
				// The file name without the extension is used as the route
				parse(file)
					// Dots in the filename become slashes
					.name.replaceAll(".", "/")
					// Variables are denoted by a $ and are replaced with a colon
					.replaceAll("$", ":")
					// The index route ends with a slash
					.replaceAll("_index", ""),
		}));

	await routes(files, routeOut, report);
	await routeConfig(files, routeConfigOut, report);

	report.entries.map((entry) => console.log(entry));
}

async function routes(routes: IGenerateParams[], routeOut: string, report: GeneratedFilesReporter) {
	const fileContents = `${GENERATED_HEADER_TS}
	// Generated by hendriksRouteGenerator.ts
export const routes = [
\t${routes.map(({ route }) => JSON.stringify(route)).join(",\n\t")}
] as const;

export type RouteDef = typeof routes[number];

export type RouterArgs =
	| ${routes
		// This generates a union type of all the routes using template literal types in place of the variables.
		// Example:
		// /repositories/:repositoryId/samples/:sampleId/     becomes
		// `repositories/${string}/samples/${string}/`

		// Split the route into its parts
		.map(({ route }) => {
			const variables = route
				.split("/")
				.filter((part) => part[0] === ":")
				.map((part) => `${part.slice(1)}: string`)
				.join("; ");

			if (variables) {
				return `["${route}", { ${variables} }]`;
			}

			return `["${route}"]`;
		})

		.join("\n\t| ")};
`;

	await safeWriteGeneratedFile("./src/routes.ts", fileContents, report, true);
}

/**
 * @param routes
 * @param routeConfigOut
 */
async function routeConfig(
	routes: IGenerateParams[],
	routeConfigOut: string,
	report: GeneratedFilesReporter
) {
	const routeConfig = `${GENERATED_HEADER_TS}
// Generated by hendriksRouteGenerator.ts
/* eslint-disable import/order */
import type { ComponentType } from "react";

import type { IRouteGetDataFunction } from "./IRouteConfig";
${routes.map(({ file }, i) => `import * as r${i} from "./routes/${parse(file).name}"`).join("\n")}

const route: {
\tredirect?: string;
\tgetData?: IRouteGetDataFunction;
\tdefault?: ComponentType<any>;
}[] = [${routes.map((_, i) => `r${i}`).join(", ")}];

export const routeConfig = {
	${routes
		.map(({ route }, i) => {
			return `${JSON.stringify(
				route
			)}: { redirect: route[${i}].redirect, getData: route[${i}].getData, Component: route[${i}].default }`;
		})
		.join(",\n\t")}
}
`;

	await safeWriteGeneratedFile(routeConfigOut, routeConfig, report, true);
}

interface IGenerateParams {
	file: string;
	route: string;
}

void main();
